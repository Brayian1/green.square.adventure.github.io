<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Пиксельная игра - Приключения квадрата</title>
    <audio id="coinSound" preload="auto">
      <source
        src="https://assets.mixkit.co/sfx/preview/mixkit-game-ball-tap-2073.mp3"
        type="audio/mpeg"
      />
      <source
        src="https://assets.mixkit.co/sfx/preview/mixkit-game-ball-tap-2073.ogg"
        type="audio/ogg"
      />
      Ваш браузер не поддерживает HTML5 аудио.
    </audio>
    <audio id="hitSound" preload="auto">
      <source
        src="https://assets.mixkit.co/sfx/preview/mixkit-boxing-punch-2051.mp3"
        type="audio/mpeg"
      />
      <source
        src="https://assets.mixkit.co/sfx/preview/mixkit-boxing-punch-2051.ogg"
        type="audio/ogg"
      />
      Ваш браузер не поддерживает HTML5 аудио.
    </audio>
    <audio id="waveSound" preload="auto">
      <source
        src="https://assets.mixkit.co/sfx/preview/mixkit-universal-laser-448.mp3"
        type="audio/mpeg"
      />
      <source
        src="https://assets.mixkit.co/sfx/preview/mixkit-universal-laser-448.ogg"
        type="audio/ogg"
      />
      Ваш браузер не поддерживает HTML5 аудио.
    </audio>
    <audio id="magnetSound" preload="auto">
      <source
        src="https://assets.mixkit.co/sfx/preview/mixkit-positive-notification-948.mp3"
        type="audio/mpeg"
      />
      <source
        src="https://assets.mixkit.co/sfx/preview/mixkit-positive-notification-948.ogg"
        type="audio/ogg"
      />
      Ваш браузер не поддерживает HTML5 аудио.
    </audio>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        color: #333;
        overflow: hidden;
      }
      .game-container {
        text-align: center;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-width: 95vw;
        width: 95vw;
        height: 95vh;
        display: flex;
        flex-direction: column;
      }
      h1 {
        color: #4a5568;
        margin-bottom: 15px;
        font-size: 2.8em;
        font-weight: 700;
        background: linear-gradient(45deg, #667eea, #764ba2);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .exp-container {
        margin-bottom: 15px;
        padding: 10px 20px;
        background: #f7fafc;
        border-radius: 15px;
        border: 1px solid #e2e8f0;
      }
      .exp-info {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        font-size: 1.1em;
        font-weight: 600;
        color: #4a5568;
      }
      .exp-bar-outer {
        width: 100%;
        height: 20px;
        background: #e2e8f0;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      .exp-bar-inner {
        height: 100%;
        background: linear-gradient(90deg, #d69e2e, #f6e05e);
        border-radius: 10px;
        transition: width 0.3s ease;
        position: relative;
      }
      .exp-glow {
        position: absolute;
        top: 0;
        right: 0;
        width: 20px;
        height: 20px;
        background: #fff9c4;
        border-radius: 50%;
        transform: translate(50%, 25%);
        opacity: 0.7;
        animation: pulse 1.5s ease-in-out infinite;
      }
      @keyframes pulse {
        0% {
          transform: translate(50%, 25%) scale(1);
          opacity: 0.7;
        }
        50% {
          transform: translate(50%, 25%) scale(1.2);
          opacity: 1;
        }
        100% {
          transform: translate(50%, 25%) scale(1);
          opacity: 0.7;
        }
      }
      .game-info {
        display: flex;
        justify-content: space-between;
        margin-bottom: 15px;
        font-size: 1.4em;
        font-weight: 600;
        flex-wrap: wrap;
        gap: 10px;
      }
      .score,
      .lives,
      .level,
      .ability {
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
        padding: 12px 20px;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        flex: 1;
        min-width: 140px;
      }
      .game-board {
        flex: 1;
        background: #1a202c;
        border-radius: 15px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        border: none;
        position: relative;
        overflow: hidden;
        margin-bottom: 15px;
        min-height: 400px;
      }
      canvas {
        border-radius: 15px;
        background: #1a202c;
        width: 100%;
        height: 100%;
        display: block;
        max-width: 100%;
        max-height: 100%;
      }
      .controls {
        font-size: 1.3em;
        color: #718096;
        font-weight: 500;
        margin-bottom: 10px;
      }
      .game-over,
      .start-screen,
      .level-complete,
      .difficulty-screen,
      .pause-screen,
      .win-screen,
      .glory-road,
      .shop-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.98);
        padding: 30px;
        border-radius: 20px;
        text-align: center;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
        max-width: 450px;
        width: 90%;
        z-index: 100;
      }
      .game-over h2,
      .start-screen h1,
      .level-complete h2,
      .difficulty-screen h2,
      .pause-screen h2,
      .win-screen h2,
      .glory-road h2,
      .shop-screen h2 {
        margin-bottom: 20px;
        font-size: 2em;
        font-weight: 700;
      }
      .game-over h2 {
        color: #e53e3e;
      }
      .level-complete h2,
      .difficulty-screen h2,
      .pause-screen h2,
      .win-screen h2,
      .glory-road h2,
      .shop-screen h2 {
        color: #4a5568;
      }
      .win-screen h2 {
        color: #38a169;
      }
      .instructions {
        margin: 20px 0;
        padding: 15px;
        background: rgba(74, 85, 104, 0.05);
        border-radius: 15px;
        border: 1px solid rgba(74, 85, 104, 0.1);
      }
      .description-header {
        display: flex;
        align-items: center;
        margin-bottom: 12px;
      }
      .description-icon {
        margin-right: 10px;
        color: #4a5568;
      }
      .description-header h2 {
        margin: 0;
        font-size: 1.6em;
        font-weight: 600;
        color: #4a5568;
      }
      .description-text {
        margin-bottom: 15px;
        line-height: 1.6;
        color: #4a5568;
        font-size: 1em;
        font-weight: 500;
      }
      .features-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }
      .feature-item {
        display: flex;
        align-items: flex-start;
      }
      .feature-icon {
        font-size: 1.2em;
        margin-right: 10px;
        min-width: 24px;
      }
      .feature-item p {
        margin: 0;
        line-height: 1.5;
        color: #4a5568;
        font-size: 0.95em;
      }
      @media (max-width: 480px) {
        .features-grid {
          grid-template-columns: 1fr;
        }
      }
      button {
        border: none;
        padding: 12px 25px;
        font-size: 1.1em;
        border-radius: 12px;
        cursor: pointer;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        font-weight: 600;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        margin: 8px;
      }
      .start-btn,
      .save-difficulty-btn,
      .resume-btn,
      .next-level-btn,
      .shop-btn {
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
        font-size: 1.2em;
        padding: 15px 30px;
      }
      .restart-btn,
      .quit-btn,
      .quit-to-menu-btn {
        background: linear-gradient(45deg, #e53e3e, #c53030);
        color: white;
      }
      .difficulty-btn,
      .back-to-main-btn,
      .glory-btn,
      .square-btn {
        background: linear-gradient(45deg, #4299e1, #3182ce);
        color: white;
        padding: 10px 20px;
        font-size: 1em;
      }
      .difficulty-btn.active {
        background: linear-gradient(45deg, #667eea, #764ba2);
        box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
      }
      button:active {
        transform: translateY(0);
      }
      #finalScore,
      #levelCompleteText,
      #winText {
        font-size: 1.2em;
        margin: 15px 0;
        color: #4a5568;
        font-weight: 500;
      }
      .difficulty-selector {
        margin: 15px 0;
      }
      .difficulty-selector p {
        margin-bottom: 12px;
        font-weight: 600;
        color: #4a5568;
      }
      .game-over,
      .level-complete,
      .difficulty-screen,
      .pause-screen,
      .win-screen,
      .glory-road,
      .shop-screen {
        display: none;
      }
      @media (max-width: 500px) {
        .game-container {
          padding: 15px;
          margin: 10px;
        }
        .game-info {
          flex-direction: column;
          gap: 10px;
        }
        .game-over,
        .start-screen,
        .level-complete,
        .difficulty-screen,
        .pause-screen,
        .win-screen,
        .glory-road,
        .shop-screen {
          padding: 25px 15px;
        }
        h1 {
          font-size: 1.8em;
        }
      }
      .wave-effect {
        position: absolute;
        border-radius: 50%;
        pointer-events: none;
        transform: translate(-50%, -50%);
        border: 2px solid rgba(124, 58, 237, 0.7);
        background: radial-gradient(
          circle,
          rgba(124, 58, 237, 0.3) 0%,
          rgba(124, 58, 237, 0) 70%
        );
        animation: wavePulse 0.5s ease-out forwards;
      }
      @keyframes wavePulse {
        0% {
          width: 0;
          height: 0;
          opacity: 1;
        }
        100% {
          width: 200px;
          height: 200px;
          opacity: 0;
        }
      }
      .magnet-effect {
        position: absolute;
        border-radius: 50%;
        pointer-events: none;
        transform: translate(-50%, -50%);
        border: 2px solid rgba(72, 187, 120, 0.7);
        background: radial-gradient(
          circle,
          rgba(72, 187, 120, 0.3) 0%,
          rgba(72, 187, 120, 0) 70%
        );
        animation: magnetPulse 0.3s ease-out forwards;
      }
      @keyframes magnetPulse {
        0% {
          width: 0;
          height: 0;
          opacity: 1;
        }
        100% {
          width: 150px;
          height: 150px;
          opacity: 0;
        }
      }
      .magnet-line {
        position: absolute;
        height: 2px;
        background: rgba(72, 187, 120, 0.7);
        transform-origin: 0 0;
        pointer-events: none;
      }
      .glory-road {
        max-width: 500px;
        width: 90%;
      }
      .glory-road h2 {
        margin-bottom: 25px;
      }
      .episodes {
        display: flex;
        flex-direction: column;
        gap: 25px;
      }
      .episode {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .episode-title {
        font-size: 1.4em;
        font-weight: 600;
        color: #4a5568;
        margin-bottom: 12px;
      }
      .levels {
        display: flex;
        justify-content: center;
        gap: 8px;
      }
      .level-dot {
        width: 35px;
        height: 35px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        color: white;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .level-dot.locked {
        background: #cbd5e0;
        cursor: not-allowed;
      }
      .level-dot.completed {
        background: #38a169;
      }
      .level-dot.current {
        background: #4299e1;
      }
      .level-dot:hover:not(.locked) {
        transform: scale(1.1);
      }
      .shop-screen {
        max-width: 500px;
        width: 90%;
      }
      .shop-screen h2 {
        margin-bottom: 25px;
      }
      .tab-btn {
        background: #e2e8f0;
        color: #4a5568;
        border: none;
        padding: 10px 20px;
        margin: 0 4px;
        font-size: 1em;
        border-radius: 8px 8px 0 0;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s;
      }
      .tab-btn.active {
        background: #667eea;
        color: white;
      }
      .tab-btn:hover:not(.active) {
        background: #4a5568;
        color: white;
      }
      .shop-items {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-bottom: 25px;
      }
      .shop-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #f7fafc;
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      }
      .shop-item h3 {
        margin: 0 0 8px 0;
        color: #4a5568;
        font-size: 1.3em;
      }
      .shop-item p {
        margin: 0 0 12px 0;
        color: #718096;
        font-size: 0.95em;
      }
      .shop-item button {
        width: 100%;
        background: linear-gradient(45deg, #48bb78, #38a169);
        color: white;
        padding: 10px;
        font-size: 1em;
      }
      .shop-item button:disabled {
        background: #cbd5e0;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      .shop-item button:hover:disabled {
        transform: none;
      }
      .level-indicator {
        display: flex;
        gap: 4px;
        margin: 4px 0 8px 0;
      }
      .level-dot-small {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #cbd5e0;
      }
      .level-dot-small.active {
        background: #48bb78;
      }
      .purchase-animation {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        background: #d69e2e;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        font-weight: bold;
        box-shadow: 0 0 15px rgba(214, 158, 46, 0.6);
        animation: floatUp 1.5s ease-out forwards;
        z-index: 1000;
      }
      @keyframes floatUp {
        0% {
          transform: translateY(0) rotate(0deg);
          opacity: 1;
        }
        100% {
          transform: translateY(-100px) rotate(360deg);
          opacity: 0;
        }
      }
      .notification {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #48bb78;
        color: white;
        padding: 10px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        font-weight: bold;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .notification.show {
        opacity: 1;
      }
      .reset-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.98);
        padding: 30px;
        border-radius: 20px;
        text-align: center;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
        max-width: 450px;
        width: 90%;
        z-index: 100;
      }
      /* Анимации прокачки */
      .upgrade-animation {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 300px;
        height: 300px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        font-weight: bold;
        font-size: 1.5em;
        z-index: 2000;
        pointer-events: none;
      }
      .upgrade-animation.level-1 {
        background: radial-gradient(circle, #48bb78 0%, #2f855a 70%);
        box-shadow: 0 0 30px rgba(72, 187, 120, 0.8);
        animation: pulse 1s ease-out forwards;
      }
      .upgrade-animation.level-2 {
        background: radial-gradient(circle, #3182ce 0%, #2c5282 70%);
        box-shadow: 0 0 30px rgba(49, 130, 206, 0.8),
          0 0 60px rgba(49, 130, 206, 0.5);
        animation: pulseShine 1.5s ease-out forwards;
      }
      .upgrade-animation.level-3 {
        background: linear-gradient(
          45deg,
          #667eea,
          #764ba2,
          #f093fb,
          #f5576c,
          #4facfe
        );
        background-size: 300% 300%;
        animation: pulseShineRainbow 2s ease-out forwards,
          rainbow 3s linear infinite;
      }
      @keyframes pulse {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 0;
        }
        70% {
          transform: translate(-50%, -50%) scale(1.2);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
      }
      @keyframes pulseShine {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 0;
          box-shadow: 0 0 30px rgba(49, 130, 206, 0.8);
        }
        50% {
          transform: translate(-50%, -50%) scale(1.3);
          opacity: 1;
          box-shadow: 0 0 60px rgba(49, 130, 206, 0.9),
            0 0 80px rgba(49, 130, 206, 0.6);
        }
        70% {
          transform: translate(-50%, -50%) scale(1.1);
          box-shadow: 0 0 50px rgba(49, 130, 206, 0.8),
            0 0 70px rgba(49, 130, 206, 0.5);
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          box-shadow: 0 0 30px rgba(49, 130, 206, 0.8);
        }
      }
      @keyframes pulseShineRainbow {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 0;
          box-shadow: 0 0 30px rgba(102, 126, 234, 0.8);
        }
        40% {
          transform: translate(-50%, -50%) scale(1.4);
          opacity: 1;
          box-shadow: 0 0 60px rgba(102, 126, 234, 0.9),
            0 0 80px rgba(118, 75, 162, 0.6), 0 0 100px rgba(240, 147, 251, 0.7);
        }
        60% {
          transform: translate(-50%, -50%) scale(1.2);
          box-shadow: 0 0 50px rgba(102, 126, 234, 0.8),
            0 0 70px rgba(118, 75, 162, 0.6);
        }
        80% {
          transform: translate(-50%, -50%) scale(1.05);
          box-shadow: 0 0 40px rgba(240, 147, 251, 0.7),
            0 0 60px rgba(245, 87, 108, 0.6);
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          box-shadow: 0 0 30px rgba(102, 126, 234, 0.8);
        }
      }
      @keyframes rainbow {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }
      /* Эффекты для анимации уровня 2 */
      .shine-effect {
        position: absolute;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: white;
        opacity: 0.8;
        pointer-events: none;
      }
      /* Эффекты для анимации уровня 3 */
      .sparkle {
        position: absolute;
        width: 6px;
        height: 6px;
        border-radius: 50%;
        pointer-events: none;
        opacity: 0;
      }
      .star {
        position: absolute;
        width: 0;
        height: 0;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        border-bottom: 10px solid yellow;
        transform: rotate(35deg);
        opacity: 0;
        pointer-events: none;
      }
      /* Стили для кнопок в меню */
      .menu-buttons {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 20px;
      }
      .menu-row {
        display: flex;
        justify-content: center;
        gap: 12px;
      }
      .menu-row .square-btn {
        width: 50px;
        height: 50px;
        min-width: 50px;
        min-height: 50px;
        padding: 0;
        border-radius: 10px;
        font-size: 1.1em;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .menu-row .start-btn {
        min-width: 150px;
        height: 50px;
        border-radius: 10px;
        font-size: 1.1em;
      }
      .menu-row .difficulty-btn {
        min-width: 150px;
        height: 50px;
        border-radius: 10px;
        font-size: 1.1em;
      }
      @media (max-width: 480px) {
        .menu-row .square-btn {
          width: 45px;
          height: 45px;
          min-width: 45px;
          min-height: 45px;
          font-size: 0.9em;
        }
        .menu-row .start-btn,
        .menu-row .difficulty-btn {
          min-width: 130px;
          height: 45px;
          font-size: 1em;
        }
      }
      /* Новые стили для бонусов */
      .bonus-tab-btn {
        background: linear-gradient(45deg, #d69e2e, #f6e05e);
        color: white;
        border: none;
        padding: 10px 20px;
        margin: 0 4px;
        font-size: 1em;
        border-radius: 8px 8px 0 0;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s;
        box-shadow: 0 4px 15px rgba(214, 158, 46, 0.3);
      }
      .bonus-tab-btn:hover:not(.active) {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(214, 158, 46, 0.5);
      }
      .bonus-tab-btn.active {
        background: linear-gradient(45deg, #f6e05e, #fefcbf);
        color: #744210;
        box-shadow: 0 0 15px rgba(246, 224, 94, 0.5);
        transform: translateY(-2px);
      }
      .bonus-item {
        background: linear-gradient(135deg, #fefce8, #fffbeb);
        border: 2px solid #f59e0b;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 4px 15px rgba(245, 158, 11, 0.2);
        text-align: center;
        animation: pulseYellow 2s infinite;
      }
      @keyframes pulseYellow {
        0% {
          box-shadow: 0 4px 15px rgba(245, 158, 11, 0.2);
        }
        50% {
          box-shadow: 0 4px 25px rgba(245, 158, 11, 0.4);
        }
        100% {
          box-shadow: 0 4px 15px rgba(245, 158, 11, 0.2);
        }
      }
      .daily-bonus-icon {
        font-size: 2.5em;
        margin-bottom: 10px;
        color: #d69e2e;
        text-shadow: 0 0 10px rgba(214, 158, 46, 0.5);
      }
      .bonus-title {
        font-size: 1.4em;
        font-weight: 700;
        color: #744210;
        margin-bottom: 8px;
      }
      .bonus-desc {
        font-size: 0.95em;
        color: #92400e;
        margin-bottom: 15px;
        line-height: 1.4;
      }
      .bonus-btn {
        background: linear-gradient(45deg, #d69e2e, #f6e05e);
        color: #744210;
        font-weight: 700;
        border: 2px solid #f59e0b;
        box-shadow: 0 4px 15px rgba(214, 158, 46, 0.3);
      }
      .bonus-btn:hover:not(:disabled) {
        background: linear-gradient(45deg, #f6e05e, #fefcbf);
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(214, 158, 46, 0.5);
      }
      .bonus-btn:disabled {
        background: #fbbf24;
        color: #744210;
        opacity: 0.7;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      /* Стили для значка сброса */
      .reset-badge {
        position: absolute;
        top: -10px;
        right: -10px;
        background: #e53e3e;
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        font-size: 0.9em;
        box-shadow: 0 0 10px rgba(229, 62, 62, 0.6);
        border: 2px solid white;
      }
      .reset-locked {
        background: #4a5568;
      }
      .reset-tooltip {
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: #1a202c;
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 0.9em;
        white-space: nowrap;
        opacity: 0;
        transition: opacity 0.3s;
        pointer-events: none;
      }
      .reset-tooltip::after {
        content: '';
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 5px solid transparent;
        border-top-color: #1a202c;
      }
      .reset-locked:hover .reset-tooltip {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <!-- Экран сброса прогресса -->
    <div class="reset-screen" id="resetScreen">
      <h2>СБРОС ПРОГРЕССА</h2>
      <p style="margin: 15px 0; color: #4a5568; font-size: 1.1em">
        Вы уверены, что хотите начать игру с нуля?
      </p>
      <p style="margin: 15px 0; color: #718096; font-size: 0.9em">
        Будет удален весь прогресс: уровень, монеты, улучшения и история
        прохождения.
      </p>
      <p style="margin: 15px 0; color: #718096; font-size: 0.9em">
        <strong>Внимание:</strong> Сброс возможен только каждые 10 уровней ранга.
      </p>
      <button class="restart-btn" onclick="confirmReset()">
        ДА, СБРОСИТЬ ВСЁ
      </button>
      <button class="back-to-main-btn" onclick="cancelReset()">
        НЕТ, ОСТАВИТЬ ПРОГРЕСС
      </button>
    </div>
    <div class="start-screen" id="startScreen">
      <h1>ПРИКЛЮЧЕНИЯ КВАДРАТА</h1>
      <div class="exp-container">
        <div class="exp-info">
          <span>Ранг: <span id="rankLevelStart">1</span></span>
          <span
            ><span id="currentExpStart">0</span>/<span id="requiredExpStart"
              >100</span
            >
            EXP</span
          >
        </div>
        <div class="exp-bar-outer">
          <div class="exp-bar-inner" id="expBarStart">
            <div class="exp-glow"></div>
          </div>
        </div>
      </div>
      <div class="instructions">
        <div class="description-header">
          <svg
            class="description-icon"
            width="30"
            height="30"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z"
              stroke="#4A5568"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
            <path
              d="M12 16V12"
              stroke="#4A5568"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
            <path
              d="M12 8H12.01"
              stroke="#4A5568"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          <h2>О квадрате</h2>
        </div>
        <p class="description-text">
          Квадрат очень не любит злых квадратов, помогите ему спастись пройдя
          уровни!
        </p>
        <div class="features-grid">
          <div class="feature-item">
            <div class="feature-icon">🎮</div>
            <p>Управляйте зеленым квадратом клавишами WASD</p>
          </div>
          <div class="feature-item">
            <div class="feature-icon">🟡</div>
            <p>Собирайте желтые монеты</p>
          </div>
          <div class="feature-item">
            <div class="feature-icon">🔴</div>
            <p>Избегайте красных врагов</p>
          </div>
          <div class="feature-item">
            <div class="feature-icon">🔵</div>
            <p>Остерегайтесь синих стрелков с 7 уровня!</p>
          </div>
          <div class="feature-item">
            <div class="feature-icon">💥</div>
            <p>SPACE - волна раз в 3 секунды</p>
          </div>
          <div class="feature-item">
            <div class="feature-icon">🧲</div>
            <p>SHIFT - магнит раз в 5 секунд</p>
          </div>
        </div>
      </div>
      <div
        class="total-coins"
        style="
          font-size: 1.3em;
          font-weight: 600;
          color: #d69e2e;
          margin: 15px 0;
        "
      >
        Всего монет: <span id="totalCoins">0</span>
      </div>
      <div class="menu-buttons">
        <div class="menu-row">
          <button class="square-btn glory-btn" onclick="showGloryRoad()">
            🏆
          </button>
          <button class="start-btn" onclick="startGame()">НАЧАТЬ</button>
          <button class="square-btn shop-btn" onclick="showShop()">🛒</button>
        </div>
        <div class="menu-row">
          <button class="square-btn" onclick="showResetScreen()">
            <div class="reset-locked" id="resetButton">
              🔄
              <div class="reset-badge" id="resetBadge">0</div>
              <div class="reset-tooltip" id="resetTooltip">
                Сброс возможен на 10, 20, 30... рангах
              </div>
            </div>
          </button>
          <button class="difficulty-btn" onclick="showDifficultyScreen()">
            НАСТРОЙКИ
          </button>
          <button
            class="square-btn"
            disabled
            style="visibility: hidden"
          ></button>
        </div>
      </div>
    </div>
    <!-- === ЭКРАН ИСТОРИИ === -->
    <div class="glory-road" id="gloryRoad">
      <h2>ИСТОРИЯ</h2>
      <div class="episodes">
        <div class="episode">
          <div class="episode-title">Эпизод 1: Начало приключений</div>
          <div class="levels" id="episode1Levels"></div>
        </div>
        <div class="episode">
          <div class="episode-title">Эпизод 2: Тёмные глубины</div>
          <div class="levels" id="episode2Levels"></div>
        </div>
      </div>
      <button
        class="back-to-main-btn"
        style="margin-top: 25px"
        onclick="showStartScreen()"
      >
        НАЗАД
      </button>
    </div>
    <!-- === ЭКРАН МАГАЗИНА === -->
    <div class="shop-screen" id="shopScreen">
      <h2>МАГАЗИН</h2>
      <div style="display: flex; justify-content: center; margin-bottom: 15px">
        <button
          id="tab-abilities"
          class="tab-btn active"
          onclick="switchTab('abilities')"
        >
          Способности
        </button>
        <button id="tab-power" class="tab-btn" onclick="switchTab('power')">
          Сила
        </button>
        <button
          id="tab-bonuses"
          class="bonus-tab-btn"
          onclick="switchTab('bonuses')"
        >
          Бонусы
        </button>
      </div>
      <div class="shop-items" id="shopItems">
        <!-- Динамически подгружается -->
      </div>
      <button class="back-to-main-btn" onclick="showStartScreen()">
        НАЗАД
      </button>
    </div>
    <!-- === ОСТАЛЬНЫЕ ЭКРАНЫ === -->
    <div class="difficulty-screen" id="difficultyScreen">
      <h2>ВЫБОР СЛОЖНОСТИ</h2>
      <div class="difficulty-selector">
        <p>Выберите уровень сложности:</p>
        <button
          class="difficulty-btn active"
          id="easyBtn"
          onclick="setDifficulty('easy')"
        >
          ЛЕГКАЯ
        </button>
        <button
          class="difficulty-btn"
          id="hardBtn"
          onclick="setDifficulty('hard')"
        >
          СЛОЖНАЯ
        </button>
      </div>
      <button class="save-difficulty-btn" onclick="saveAndReturnToMain()">
        СОХРАНИТЬ И ВЫЙТИ
      </button>
      <button class="back-to-main-btn" onclick="showStartScreen()">
        НАЗАД
      </button>
    </div>
    <div class="pause-screen" id="pauseScreen">
      <h2>ПАУЗА</h2>
      <p>Игра приостановлена</p>
      <button class="resume-btn" onclick="resumeGame()">ПРОДОЛЖИТЬ</button>
      <button class="quit-btn" onclick="quitToMainMenu()">ВЫЙТИ В МЕНЮ</button>
    </div>
    <div class="level-complete" id="levelComplete">
      <h2>УРОВЕНЬ ПРОЙДЕН!</h2>
      <p id="levelCompleteText">Поздравляем! Переходите к следующему уровню.</p>
      <button class="next-level-btn" onclick="nextLevel()">
        СЛЕДУЮЩИЙ УРОВЕНЬ
      </button>
      <button class="quit-to-menu-btn" onclick="quitToMainMenuFromScreen()">
        ВЫЙТИ В МЕНЮ
      </button>
    </div>
    <div class="win-screen" id="winScreen">
      <h2>ПОБЕДА!</h2>
      <p id="winText">Вы прошли все 10 уровней!</p>
      <button class="restart-btn" onclick="restartGame()">ИГРАТЬ СНОВА</button>
      <button class="quit-to-menu-btn" onclick="quitToMainMenuFromScreen()">
        ВЫЙТИ В МЕНЮ
      </button>
    </div>
    <div class="game-over" id="gameOver">
      <h2>ИГРА ОКОНЧЕНА</h2>
      <p id="finalScore">Счет: 0</p>
      <button class="restart-btn" onclick="restartGame()">ИГРАТЬ СНОВА</button>
      <button class="quit-to-menu-btn" onclick="quitToMainMenuFromScreen()">
        ВЫЙТИ В МЕНЮ
      </button>
    </div>
    <div class="game-container" id="gameContainer" style="display: none">
      <h1>ПРИКЛЮЧЕНИЯ КВАДРАТА</h1>
      <div class="exp-container">
        <div class="exp-info">
          <span>Ранг: <span id="rankLevel">1</span></span>
          <span
            ><span id="currentExp">0</span>/<span id="requiredExp">100</span>
            EXP</span
          >
        </div>
        <div class="exp-bar-outer">
          <div class="exp-bar-inner" id="expBar">
            <div class="exp-glow"></div>
          </div>
        </div>
      </div>
      <div class="game-info">
        <div class="score">Счет: <span id="score">0</span></div>
        <div class="level">Уровень: <span id="level">1</span></div>
        <div class="lives">Жизни: <span id="lives">10</span></div>
        <div class="ability">
          <div>Волна: <span id="waveCooldown">Готова</span></div>
          <div>Магнит: <span id="magnetCooldown">Готов</span></div>
        </div>
      </div>
      <div class="game-board">
        <canvas id="gameCanvas"></canvas>
      </div>
      <div class="controls">
        <p>WASD - движение. SPACE - волна. SHIFT - магнит. ESC - пауза</p>
      </div>
    </div>
    <!-- Уведомления и анимации -->
    <div id="notification" class="notification"></div>
    <script>
      // Вспомогательная функция для преобразования hex в rgb
      function hexToRgb(hex) {
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(
          shorthandRegex,
          (m, r, g, b) => r + r + g + g + b + b
        );
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result
          ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(
              result[3],
              16
            )}`
          : "255, 0, 0";
      }
      // Игровые переменные
      let canvas, ctx;
      let player = { x: 400, y: 500, size: 30, speed: 3, color: "#48bb78" };
      let coins = [];
      let enemies = [];
      let bullets = [];
      let score = 0;
      let lives = 10;
      let maxLives = 10;
      let currentLevel = 1;
      let gameRunning = false;
      let gamePaused = false;
      let keys = {};
      let gameLoop;
      let difficulty = "easy";
      const coinAudio = document.getElementById("coinSound");
      const hitAudio = document.getElementById("hitSound");
      const waveAudio = document.getElementById("waveSound");
      const magnetAudio = document.getElementById("magnetSound");
      let lastWaveTime = 0;
      let baseWaveCooldown = 3000;
      let waveCooldown = baseWaveCooldown;
      const waveRadius = 100;
      let lastMagnetTime = 0;
      let baseMagnetCooldown = 5000;
      let magnetCooldown = baseMagnetCooldown;
      const magnetRadius = 150;
      const magnetStrength = 0.15;
      let isMagnetActive = false;
      let trail = [];
      const maxTrailLength = 20;
      let magnetLines = [];
      const levelSettings = {
        easy: {
          1: {
            coins: 15,
            enemies: 5,
            winScore: 30,
            enemySpeed: 0.8,
            bigEnemies: 0,
            bigEnemyChance: 0,
            shooters: 0,
          },
          2: {
            coins: 20,
            enemies: 7,
            winScore: 50,
            enemySpeed: 1.0,
            bigEnemies: 0,
            bigEnemyChance: 0,
            shooters: 0,
          },
          3: {
            coins: 25,
            enemies: 9,
            winScore: 75,
            enemySpeed: 1.2,
            bigEnemies: 1,
            bigEnemyChance: 0.2,
            shooters: 0,
          },
          4: {
            coins: 30,
            enemies: 11,
            winScore: 105,
            enemySpeed: 1.4,
            bigEnemies: 2,
            bigEnemyChance: 0.4,
            shooters: 0,
          },
          5: {
            coins: 35,
            enemies: 13,
            winScore: 150,
            enemySpeed: 1.6,
            bigEnemies: 3,
            bigEnemyChance: 0.6,
            shooters: 0,
          },
          6: {
            coins: 40,
            enemies: 14,
            winScore: 180,
            enemySpeed: 1.7,
            bigEnemies: 3,
            bigEnemyChance: 0.7,
            shooters: 0,
          },
          7: {
            coins: 45,
            enemies: 15,
            winScore: 220,
            enemySpeed: 1.8,
            bigEnemies: 4,
            bigEnemyChance: 0.7,
            shooters: 1,
          },
          8: {
            coins: 50,
            enemies: 16,
            winScore: 270,
            enemySpeed: 1.9,
            bigEnemies: 5,
            bigEnemyChance: 0.8,
            shooters: 2,
          },
          9: {
            coins: 55,
            enemies: 18,
            winScore: 330,
            enemySpeed: 2.0,
            bigEnemies: 5,
            bigEnemyChance: 0.8,
            shooters: 2,
          },
          10: {
            coins: 60,
            enemies: 20,
            winScore: 400,
            enemySpeed: 2.2,
            bigEnemies: 6,
            bigEnemyChance: 0.9,
            shooters: 3,
          },
        },
        hard: {
          1: {
            coins: 15,
            enemies: 5,
            winScore: 60,
            enemySpeed: 1.0,
            bigEnemies: 0,
            bigEnemyChance: 0,
            shooters: 0,
          },
          2: {
            coins: 20,
            enemies: 7,
            winScore: 100,
            enemySpeed: 1.2,
            bigEnemies: 0,
            bigEnemyChance: 0,
            shooters: 0,
          },
          3: {
            coins: 25,
            enemies: 9,
            winScore: 150,
            enemySpeed: 1.4,
            bigEnemies: 1,
            bigEnemyChance: 0.2,
            shooters: 0,
          },
          4: {
            coins: 30,
            enemies: 11,
            winScore: 210,
            enemySpeed: 1.6,
            bigEnemies: 2,
            bigEnemyChance: 0.4,
            shooters: 0,
          },
          5: {
            coins: 35,
            enemies: 13,
            winScore: 300,
            enemySpeed: 1.8,
            bigEnemies: 3,
            bigEnemyChance: 0.6,
            shooters: 0,
          },
          6: {
            coins: 40,
            enemies: 14,
            winScore: 450,
            enemySpeed: 1.9,
            bigEnemies: 3,
            bigEnemyChance: 0.7,
            shooters: 0,
          },
          7: {
            coins: 45,
            enemies: 16,
            winScore: 550,
            enemySpeed: 2.0,
            bigEnemies: 4,
            bigEnemyChance: 0.7,
            shooters: 1,
          },
          8: {
            coins: 50,
            enemies: 18,
            winScore: 660,
            enemySpeed: 2.1,
            bigEnemies: 5,
            bigEnemyChance: 0.8,
            shooters: 2,
          },
          9: {
            coins: 55,
            enemies: 20,
            winScore: 780,
            enemySpeed: 2.2,
            bigEnemies: 5,
            bigEnemyChance: 0.8,
            shooters: 2,
          },
          10: {
            coins: 60,
            enemies: 22,
            winScore: 900,
            enemySpeed: 2.4,
            bigEnemies: 6,
            bigEnemyChance: 0.9,
            shooters: 3,
          },
        },
      };
      const MIN_SPAWN_DISTANCE = 150;
      // Прогресс
      let totalCoins = 0;
      let unlockedLevels = 1;
      let completedLevels = [];
      let unlockedEpisodes = 1;
      let lastAttemptedLevel = 1;
      // Улучшения (теперь с уровнями)
      let upgrades = {
        wave: 0,
        magnet: 0,
        health: 0,
        speed: 0,
      };
      // Конфигурация улучшений с тремя уровнями
      const upgradeConfig = {
        wave: {
          maxLevel: 3,
          baseCooldown: 3000,
          cooldownReduction: [1000, 700, 500], // Снижение перезарядки на каждый уровень
          costs: [800, 1500, 2500],
          effects: [
            "Сокращает перезарядку с 3 до 2 секунд",
            "Сокращает перезарядку до 1.3 секунд",
            "Сокращает перезарядку до 0.8 секунд",
          ],
        },
        magnet: {
          maxLevel: 3,
          baseCooldown: 5000,
          cooldownReduction: [2000, 1500, 1000],
          costs: [1000, 1800, 3000],
          effects: [
            "Сокращает перезарядку с 5 до 3 секунд",
            "Сокращает перезарядку до 1.5 секунд",
            "Сокращает перезарядку до 0.5 секунд",
          ],
        },
        health: {
          maxLevel: 3,
          baseHealth: 10,
          healthIncrease: [2, 2, 2],
          costs: [2000, 3500, 5000],
          effects: [
            "Увеличивает макс. жизни с 10 до 12",
            "Увеличивает макс. жизни до 14",
            "Увеличивает макс. жизни до 16",
          ],
        },
        speed: {
          maxLevel: 3,
          baseSpeed: 3,
          speedIncrease: [0.5, 0.4, 0.3],
          costs: [2200, 3800, 5500],
          effects: [
            "Увеличивает скорость передвижения на 0.5",
            "Увеличивает скорость на 0.9 всего",
            "Увеличивает скорость на 1.2 всего",
          ],
        },
      };
      // Система рангов
      let rankLevel = 1;
      let currentExp = 0;
      let requiredExp = 100;
      // Система сброса прогресса
      let resetCount = 0;
      // Функция для расчета необходимого опыта для следующего уровня
      function calculateRequiredExp(level) {
        // Формула: 100, 250, 450, 700, 1000, 1350, 1750, 2200, 2700, 3250...
        // Рост: +150, +200, +250, +300, +350, +400, +450, +500...
        // Это квадратичная последовательность: 25 * n² + 75 * n
        return 25 * level * level + 75 * level;
      }
      // Обновление панели опыта
      function updateExpBar() {
        const expPercentage = (currentExp / requiredExp) * 100;
        document.getElementById("expBar").style.width = expPercentage + "%";
        document.getElementById("rankLevel").textContent = rankLevel;
        document.getElementById("currentExp").textContent = currentExp;
        document.getElementById("requiredExp").textContent = requiredExp;
        // Обновляем панель опыта на главном экране
        if (document.getElementById("expBarStart")) {
          document.getElementById("expBarStart").style.width =
            expPercentage + "%";
          document.getElementById("rankLevelStart").textContent = rankLevel;
          document.getElementById("currentExpStart").textContent = currentExp;
          document.getElementById("requiredExpStart").textContent = requiredExp;
        }
        // Обновляем доступность сброса
        updateResetButton();
      }
      // Проверка, можно ли сбросить прогресс
      function canResetProgress() {
        return rankLevel % 10 === 0 && rankLevel > 0;
      }
      // Обновление кнопки сброса
      function updateResetButton() {
        const resetButton = document.getElementById("resetButton");
        const resetBadge = document.getElementById("resetBadge");
        const resetTooltip = document.getElementById("resetTooltip");
        
        if (canResetProgress()) {
          resetButton.classList.remove("reset-locked");
          resetButton.style.cursor = "pointer";
          resetTooltip.style.display = "none";
        } else {
          resetButton.classList.add("reset-locked");
          resetButton.style.cursor = "not-allowed";
          resetTooltip.style.display = "block";
        }
        
        resetBadge.textContent = resetCount;
      }
      // Добавление опыта
      function addExp(amount) {
        currentExp += amount;
        // Проверка на повышение уровня
        while (currentExp >= requiredExp) {
          currentExp -= requiredExp;
          rankLevel++;
          requiredExp = calculateRequiredExp(rankLevel);
          // Анимация повышения уровня
          showNotification(`🎉 Поздравляем! Вы достигли ${rankLevel} ранга!`);
          // Случайное улучшение при повышении ранга
          if (rankLevel % 5 === 0) {
            showNotification(
              `🎁 Бонус! Получено 50 монет за достижение ${rankLevel} ранга!`
            );
            totalCoins += 50;
            document.getElementById("totalCoins").textContent = totalCoins;
          }
          // Обновляем кнопку сброса при повышении ранга
          updateResetButton();
        }
        updateExpBar();
      }
      // === ТОВАРЫ МАГАЗИНА ===
      const shopItems = {
        abilities: [
          {
            id: "buyWaveBtn",
            title: "Улучшение волны",
            desc: "Сокращает время перезарядки волны",
            type: "wave",
          },
          {
            id: "buyMagnetBtn",
            title: "Улучшение магнита",
            desc: "Сокращает время перезарядки магнита",
            type: "magnet",
          },
        ],
        power: [
          {
            id: "buyHealthBtn",
            title: "Дополнительное здоровье",
            desc: "Увеличивает максимальное количество жизней",
            type: "health",
          },
          {
            id: "buySpeedBtn",
            title: "Увеличение скорости",
            desc: "Увеличивает скорость передвижения",
            type: "speed",
          },
        ],
        bonuses: [
          {
            id: "dailyBonusBtn",
            title: "Ежедневный бонус",
            desc: "Получайте 100 монет каждый день",
            type: "bonus",
          },
        ],
      };
      // === ПЕРЕКЛЮЧЕНИЕ ВКЛАДОК ===
      function switchTab(tab) {
        document
          .getElementById("tab-abilities")
          .classList.toggle("active", tab === "abilities");
        document
          .getElementById("tab-power")
          .classList.toggle("active", tab === "power");
        document
          .getElementById("tab-bonuses")
          .classList.toggle("active", tab === "bonuses");
        renderShopItems(tab);
      }
      // === ОТОБРАЖЕНИЕ ТОВАРОВ ===
      function renderShopItems(tab) {
        const container = document.getElementById("shopItems");
        container.innerHTML = "";
        shopItems[tab].forEach((item) => {
          const shopItem = document.createElement("div");
          if (tab === "bonuses") {
            shopItem.className = "shop-item bonus-item";
          } else {
            shopItem.className = "shop-item";
          }
          
          if (tab === "bonuses") {
            // Специальное оформление для бонусов
            const now = Date.now();
            const lastBonusTime = localStorage.getItem("lastDailyBonusTime");
            let buttonText, isDisabled = false;
            
            if (lastBonusTime && now - parseInt(lastBonusTime) < 86400000) {
              const hoursLeft = Math.ceil((86400000 - (now - parseInt(lastBonusTime))) / 3600000);
              buttonText = `Доступно через ${hoursLeft}ч`;
              isDisabled = true;
            } else {
              buttonText = "Получить 100 монет";
              isDisabled = false;
            }
            
            shopItem.innerHTML = `
              <div class="daily-bonus-icon">🎁</div>
              <h3 class="bonus-title">${item.title}</h3>
              <p class="bonus-desc">${item.desc}</p>
              <p class="bonus-desc">Получайте 100 монет каждые 24 часа</p>
              <button id="${item.id}" class="bonus-btn" onclick="claimDailyBonus()" ${
                isDisabled ? "disabled" : ""
              }>
                ${buttonText}
              </button>
            `;
          } else {
            // Обычное оформление для других категорий
            const currentLevel = upgrades[item.type];
            const config = upgradeConfig[item.type];
            const isMaxLevel = currentLevel >= config.maxLevel;
            const canAfford = totalCoins >= config.costs[currentLevel];
            // Создаем индикатор уровней
            let levelIndicator = '<div class="level-indicator">';
            for (let i = 0; i < config.maxLevel; i++) {
              levelIndicator += `<div class="level-dot-small ${
                i < currentLevel ? "active" : ""
              }"></div>`;
            }
            levelIndicator += "</div>";
            // Текст кнопки
            let buttonText;
            if (isMaxLevel) {
              buttonText = "Макс. уровень";
            } else if (canAfford) {
              buttonText = `Улучшить за ${config.costs[currentLevel]} монет`;
            } else {
              buttonText = `Недостаточно (${totalCoins}/${config.costs[currentLevel]})`;
            }
            // Описание эффекта
            const effectText = isMaxLevel
              ? `Максимальный уровень: ${config.effects[config.maxLevel - 1]}`
              : config.effects[currentLevel];
            shopItem.innerHTML = `
              <h3>${item.title}</h3>
              <p>${item.desc}</p>
              ${levelIndicator}
              <p style="color: #48bb78; font-weight: 600;">Уровень ${currentLevel}/${
                config.maxLevel
              }</p>
              <p>${effectText}</p>
              <button id="${item.id}" onclick="buyUpgrade('${item.type}')" ${
                isMaxLevel || !canAfford ? "disabled" : ""
              }>
                ${buttonText}
              </button>
            `;
          }
          container.appendChild(shopItem);
        });
      }
      // === ОБЩАЯ ФУНКЦИЯ ПОКУПКИ УЛУЧШЕНИЯ ===
      function buyUpgrade(type) {
        const config = upgradeConfig[type];
        const currentLevel = upgrades[type];
        // Проверяем, не достигнут ли максимальный уровень
        if (currentLevel >= config.maxLevel) return;
        // Проверяем, достаточно ли монет
        if (totalCoins < config.costs[currentLevel]) return;
        // Вычитаем стоимость
        totalCoins -= config.costs[currentLevel];
        upgrades[type] = currentLevel + 1;
        // Применяем эффект улучшения
        applyUpgradeEffect(type);
        // Сохраняем прогресс
        saveProgress();
        // Обновляем интерфейс
        document.getElementById("totalCoins").textContent = totalCoins;
        showPurchaseAnimation(config.costs[currentLevel]);
        // Показываем анимацию прокачки
        showUpgradeAnimation(type, upgrades[type]);
        // Показываем уведомление
        const upgradeNames = {
          wave: "волны",
          magnet: "магнита",
          health: "здоровья",
          speed: "скорости",
        };
        showNotification(
          `⚡ Уровень ${upgrades[type]} улучшения ${upgradeNames[type]} куплен!`
        );
        // Обновляем магазин
        renderShopItems(
          document.getElementById("tab-abilities").classList.contains("active")
            ? "abilities"
            : "power"
        );
      }
      
      // Новая функция для ежедневного бонуса
      function claimDailyBonus() {
        const now = Date.now();
        const lastBonusTime = localStorage.getItem("lastDailyBonusTime");
        const dailyBonusBtn = document.getElementById("dailyBonusBtn");
        if (lastBonusTime && now - parseInt(lastBonusTime) < 86400000) {
          const hoursLeft = Math.ceil(
            (86400000 - (now - parseInt(lastBonusTime))) / 3600000
          );
          dailyBonusBtn.textContent = "Доступно через " + hoursLeft + "ч";
          dailyBonusBtn.disabled = true;
          setTimeout(updateDailyBonusButton, 60000);
          showNotification("Бонус можно получить только раз в 24 часа!");
          return;
        }
        totalCoins += 100;
        localStorage.setItem("totalCoins", totalCoins);
        localStorage.setItem("lastDailyBonusTime", now);
        document.getElementById("totalCoins").textContent = totalCoins;
        dailyBonusBtn.textContent = "Бонус получен!";
        dailyBonusBtn.disabled = true;
        setTimeout(updateDailyBonusButton, 60000);
        showNotification("🎉 Вы получили 100 монет! Возвращайтесь завтра!");
        showPurchaseAnimation(100);
      }
      
      function updateDailyBonusButton() {
        const now = Date.now();
        const lastBonusTime = localStorage.getItem("lastDailyBonusTime");
        const dailyBonusBtn = document.getElementById("dailyBonusBtn");
        if (!dailyBonusBtn) return;
        if (lastBonusTime && now - parseInt(lastBonusTime) < 86400000) {
          const hoursLeft = Math.ceil(
            (86400000 - (now - parseInt(lastBonusTime))) / 3600000
          );
          dailyBonusBtn.textContent = "Доступно через " + hoursLeft + "ч";
          dailyBonusBtn.disabled = true;
          setTimeout(updateDailyBonusButton, 60000);
        } else {
          dailyBonusBtn.textContent = "Получить 100 монет";
          dailyBonusBtn.disabled = false;
        }
      }
      // === ПРИМЕНЕНИЕ ЭФФЕКТОВ УЛУЧШЕНИЙ ===
      function applyUpgradeEffect(type) {
        const config = upgradeConfig[type];
        const level = upgrades[type];
        switch (type) {
          case "wave":
            waveCooldown =
              config.baseCooldown -
              config.cooldownReduction
                .slice(0, level)
                .reduce((a, b) => a + b, 0);
            break;
          case "magnet":
            magnetCooldown =
              config.baseCooldown -
              config.cooldownReduction
                .slice(0, level)
                .reduce((a, b) => a + b, 0);
            break;
          case "health":
            maxLives =
              config.baseHealth +
              config.healthIncrease.slice(0, level).reduce((a, b) => a + b, 0);
            lives = Math.min(lives, maxLives); // Убедимся, что жизни не превышают максимум
            if (gameRunning) {
              document.getElementById("lives").textContent = lives;
            }
            break;
          case "speed":
            player.speed =
              config.baseSpeed +
              config.speedIncrease.slice(0, level).reduce((a, b) => a + b, 0);
            break;
        }
      }
      // === АНИМАЦИИ ПРОКАЧКИ ===
      function showUpgradeAnimation(type, level) {
        const upgradeNames = {
          wave: "волны",
          magnet: "магнита",
          health: "здоровья",
          speed: "скорости",
        };
        const animation = document.createElement("div");
        animation.className = `upgrade-animation level-${level}`;
        animation.textContent = `Уровень ${level}`;
        // Добавляем анимацию в документ
        document.body.appendChild(animation);
        // Добавляем дополнительные эффекты в зависимости от уровня
        if (level === 2) {
          createShineEffects();
        } else if (level === 3) {
          createRainbowEffects();
        }
        // Удаляем анимацию через 2.5 секунды
        setTimeout(() => {
          if (animation.parentNode) {
            animation.parentNode.removeChild(animation);
          }
        }, 2500);
      }
      function createShineEffects() {
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        // Создаем несколько светящихся эффектов
        for (let i = 0; i < 8; i++) {
          const shine = document.createElement("div");
          shine.className = "shine-effect";
          // Случайное положение вокруг центра
          const angle = ((i * 45 + Math.random() * 30) * Math.PI) / 180;
          const distance = 100 + Math.random() * 50;
          const x = centerX + Math.cos(angle) * distance;
          const y = centerY + Math.sin(angle) * distance;
          shine.style.left = `${x}px`;
          shine.style.top = `${y}px`;
          // Анимация появления и исчезновения
          shine.style.animation = `shinePulse 1s ease-out ${i * 0.1}s forwards`;
          document.body.appendChild(shine);
          // Удаляем эффект через 1.5 секунды
          setTimeout(() => {
            if (shine.parentNode) {
              shine.parentNode.removeChild(shine);
            }
          }, 1500);
        }
      }
      function createRainbowEffects() {
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        // Создаем разноцветные искры
        for (let i = 0; i < 15; i++) {
          const sparkle = document.createElement("div");
          sparkle.className = "sparkle";
          // Случайный цвет радуги
          const colors = [
            "#ff0000",
            "#ff7f00",
            "#ffff00",
            "#00ff00",
            "#0000ff",
            "#4b0082",
            "#9400d3",
          ];
          sparkle.style.backgroundColor = colors[i % colors.length];
          // Случайное положение
          const angle = (Math.random() * 360 * Math.PI) / 180;
          const distance = 50 + Math.random() * 100;
          const x = centerX + Math.cos(angle) * distance;
          const y = centerY + Math.sin(angle) * distance;
          sparkle.style.left = `${x}px`;
          sparkle.style.top = `${y}px`;
          // Анимация появления и движения
          sparkle.style.animation = `sparklePulse 1.5s ease-out ${
            Math.random() * 0.5
          }s forwards`;
          document.body.appendChild(sparkle);
          // Удаляем через 2 секунды
          setTimeout(() => {
            if (sparkle.parentNode) {
              sparkle.parentNode.removeChild(sparkle);
            }
          }, 2000);
        }
        // Создаем звездочки
        for (let i = 0; i < 8; i++) {
          const star = document.createElement("div");
          star.className = "star";
          const angle = (Math.random() * 360 * Math.PI) / 180;
          const distance = 70 + Math.random() * 80;
          const x = centerX + Math.cos(angle) * distance;
          const y = centerY + Math.sin(angle) * distance;
          star.style.left = `${x}px`;
          star.style.top = `${y}px`;
          star.style.animation = `starPulse 2s ease-out ${
            Math.random() * 0.8
          }s forwards`;
          document.body.appendChild(star);
          setTimeout(() => {
            if (star.parentNode) {
              star.parentNode.removeChild(star);
            }
          }, 2000);
        }
      }
      // Добавляем анимации в CSS через JavaScript
      const style = document.createElement("style");
      style.textContent = `
        @keyframes shinePulse {
          0% { transform: scale(0); opacity: 0; }
          50% { transform: scale(1.5); opacity: 1; }
          100% { transform: scale(0); opacity: 0; }
        }
        @keyframes sparklePulse {
          0% { transform: scale(0); opacity: 0; }
          30% { transform: scale(1.8); opacity: 1; }
          70% { transform: scale(1.2); opacity: 1; }
          100% { transform: scale(0); opacity: 0; }
        }
        @keyframes starPulse {
          0% { transform: scale(0) rotate(0deg); opacity: 0; }
          40% { transform: scale(1.5) rotate(180deg); opacity: 1; }
          80% { transform: scale(1.1) rotate(360deg); opacity: 1; }
          100% { transform: scale(0) rotate(360deg); opacity: 0; }
        }
      `;
      document.head.appendChild(style);
      // === ОБНОВЛЕНИЕ МАГАЗИНА ===
      function showShop() {
        document.getElementById("startScreen").style.display = "none";
        document.getElementById("shopScreen").style.display = "block";
        switchTab("abilities");
        updateDailyBonusButton();
      }
      function showPurchaseAnimation(amount) {
        const coin = document.createElement("div");
        coin.className = "purchase-animation";
        coin.textContent = "-" + amount;
        document.body.appendChild(coin);
        setTimeout(() => {
          if (coin.parentNode) coin.parentNode.removeChild(coin);
        }, 1500);
      }
      function showNotification(message) {
        const notif = document.getElementById("notification");
        notif.textContent = message;
        notif.classList.add("show");
        setTimeout(() => {
          notif.classList.remove("show");
        }, 3000);
      }
      function saveProgress() {
        localStorage.setItem("unlockedLevels", unlockedLevels);
        localStorage.setItem(
          "completedLevels",
          JSON.stringify(completedLevels)
        );
        localStorage.setItem("unlockedEpisodes", unlockedEpisodes);
        localStorage.setItem("upgrades", JSON.stringify(upgrades));
        localStorage.setItem("totalCoins", totalCoins);
        localStorage.setItem("lastAttemptedLevel", lastAttemptedLevel);
        localStorage.setItem("rankLevel", rankLevel);
        localStorage.setItem("currentExp", currentExp);
        localStorage.setItem("resetCount", resetCount);
      }
      function loadProgress() {
        unlockedLevels = parseInt(localStorage.getItem("unlockedLevels")) || 1;
        const saved = localStorage.getItem("completedLevels");
        completedLevels = saved ? JSON.parse(saved) : [];
        unlockedEpisodes =
          parseInt(localStorage.getItem("unlockedEpisodes")) || 1;
        const savedUpgrades = localStorage.getItem("upgrades");
        if (savedUpgrades) {
          upgrades = JSON.parse(savedUpgrades);
          // Применяем все улучшения
          Object.keys(upgradeConfig).forEach((type) => {
            if (upgrades[type] > 0) {
              applyUpgradeEffect(type);
            }
          });
        }
        totalCoins = parseInt(localStorage.getItem("totalCoins")) || 0;
        lastAttemptedLevel =
          parseInt(localStorage.getItem("lastAttemptedLevel")) || 1;
        rankLevel = parseInt(localStorage.getItem("rankLevel")) || 1;
        currentExp = parseInt(localStorage.getItem("currentExp")) || 0;
        requiredExp = calculateRequiredExp(rankLevel);
        resetCount = parseInt(localStorage.getItem("resetCount")) || 0;
        const totalCoinsElement = document.getElementById("totalCoins");
        if (totalCoinsElement) {
          totalCoinsElement.textContent = totalCoins;
        }
        if (document.getElementById("rankLevel")) {
          updateExpBar();
        }
      }
      // === ФУНКЦИИ СБРОСА ПРОГРЕССА ===
      function showResetScreen() {
        if (!canResetProgress()) {
          showNotification("Сброс возможен только на 10, 20, 30... рангах!");
          return;
        }
        document.getElementById("startScreen").style.display = "none";
        document.getElementById("resetScreen").style.display = "block";
      }
      function cancelReset() {
        document.getElementById("resetScreen").style.display = "none";
        document.getElementById("startScreen").style.display = "block";
      }
      function confirmReset() {
        // Увеличиваем счетчик сбросов
        resetCount++;
        // Сохраняем обновленный счетчик
        localStorage.setItem("resetCount", resetCount);
        
        // Сбрасываем все переменные, кроме ранга
        totalCoins = 0;
        unlockedLevels = 1;
        completedLevels = [];
        unlockedEpisodes = 1;
        lastAttemptedLevel = 1;
        upgrades = {
          wave: 0,
          magnet: 0,
          health: 0,
          speed: 0,
        };
        // Ранг и опыт НЕ сбрасываются
        // requiredExp уже рассчитан при загрузке
        
        // Сбрасываем все улучшения до начальных значений
        waveCooldown = baseWaveCooldown;
        magnetCooldown = baseMagnetCooldown;
        maxLives = 10;
        player.speed = 3;
        
        // Удаляем все данные из localStorage, кроме ранга и счетчика сбросов
        localStorage.removeItem("unlockedLevels");
        localStorage.removeItem("completedLevels");
        localStorage.removeItem("unlockedEpisodes");
        localStorage.removeItem("upgrades");
        localStorage.removeItem("totalCoins");
        localStorage.removeItem("lastAttemptedLevel");
        localStorage.removeItem("lastDailyBonusTime");
        // rankLevel, currentExp и resetCount сохраняются
        
        // Обновляем интерфейс
        document.getElementById("totalCoins").textContent = totalCoins;
        document.getElementById("resetScreen").style.display = "none";
        document.getElementById("startScreen").style.display = "block";
        
        // Обновляем значок сброса
        updateResetButton();
        
        // Показываем уведомление
        showNotification(`🔄 Прогресс сброшен! Вы ${resetCount} раз(а) сбрасывали прогресс.`);
      }
      // === ЭКРАН ИСТОРИИ ===
      function showGloryRoad() {
        document.getElementById("startScreen").style.display = "none";
        document.getElementById("gloryRoad").style.display = "block";
        renderGloryRoad();
      }
      function renderGloryRoad() {
        const container1 = document.getElementById("episode1Levels");
        const container2 = document.getElementById("episode2Levels");
        container1.innerHTML = "";
        container2.innerHTML = "";
        for (let i = 1; i <= 5; i++) {
          const dot = document.createElement("div");
          dot.className = "level-dot";
          dot.textContent = i;
          if (completedLevels.includes(i)) {
            dot.classList.add("completed");
          } else if (i > unlockedLevels) {
            dot.classList.add("locked");
          } else {
            dot.classList.add("current");
          }
          if (i <= unlockedLevels) {
            dot.onclick = () => {
              if (
                confirm("Начать уровень " + i + "? Ваши монеты сохранятся.")
              ) {
                currentLevel = i;
                startGame();
              }
            };
          }
          container1.appendChild(dot);
        }
        for (let i = 6; i <= 10; i++) {
          const dot = document.createElement("div");
          dot.className = "level-dot";
          dot.textContent = i;
          const isUnlocked = completedLevels.includes(5);
          if (completedLevels.includes(i)) {
            dot.classList.add("completed");
          } else if (!isUnlocked) {
            dot.classList.add("locked");
            dot.textContent = "?";
          } else if (i > unlockedLevels) {
            dot.classList.add("locked");
          } else {
            dot.classList.add("current");
          }
          if (isUnlocked && i <= unlockedLevels) {
            dot.onclick = () => {
              if (
                confirm("Начать уровень " + i + "? Ваши монеты сохранятся.")
              ) {
                currentLevel = i;
                startGame();
              }
            };
          }
          container2.appendChild(dot);
        }
      }
      // === ОСТАЛЬНЫЕ ФУНКЦИИ ===
      function showStartScreen() {
        document.getElementById("startScreen").style.display = "block";
        document.getElementById("difficultyScreen").style.display = "none";
        document.getElementById("gloryRoad").style.display = "none";
        document.getElementById("shopScreen").style.display = "none";
        document.getElementById("resetScreen").style.display = "none";
      }
      function showDifficultyScreen() {
        document.getElementById("startScreen").style.display = "none";
        document.getElementById("difficultyScreen").style.display = "block";
      }
      function saveAndReturnToMain() {
        document.getElementById("difficultyScreen").style.display = "none";
        document.getElementById("startScreen").style.display = "block";
      }
      function showPauseScreen() {
        if (gameRunning) {
          document.getElementById("pauseScreen").style.display = "block";
          gamePaused = true;
        }
      }
      function hidePauseScreen() {
        document.getElementById("pauseScreen").style.display = "none";
        gamePaused = false;
      }
      function togglePause() {
        if (gameRunning && !gamePaused) {
          showPauseScreen();
        } else if (gameRunning && gamePaused) {
          hidePauseScreen();
        }
      }
      function resumeGame() {
        hidePauseScreen();
      }
      function quitToMainMenuFromScreen() {
        document.getElementById("levelComplete").style.display = "none";
        document.getElementById("gameOver").style.display = "none";
        document.getElementById("winScreen").style.display = "none";
        quitToMainMenu();
      }
      function quitToMainMenu() {
        if (gameLoop) {
          clearInterval(gameLoop);
          gameLoop = null;
        }
        gameRunning = false;
        gamePaused = false;
        document.getElementById("gameContainer").style.display = "none";
        document.getElementById("pauseScreen").style.display = "none";
        document.getElementById("startScreen").style.display = "block";
      }
      function setDifficulty(level) {
        difficulty = level;
        document
          .getElementById("easyBtn")
          .classList.toggle("active", level === "easy");
        document
          .getElementById("hardBtn")
          .classList.toggle("active", level === "hard");
      }
      function initGame() {
        canvas = document.getElementById("gameCanvas");
        const gameBoard = document.querySelector(".game-board");
        // Устанавливаем размеры canvas с учетом размеров контейнера
        canvas.width = gameBoard.clientWidth;
        canvas.height = gameBoard.clientHeight;
        ctx = canvas.getContext("2d");
        // Устанавливаем игрока в центр арены
        player.x = canvas.width / 2 - player.size / 2;
        player.y = canvas.height / 2 - player.size / 2;
        trail = [];
        magnetLines = [];
        bullets = [];
        for (
          let i = 0;
          i < levelSettings[difficulty][currentLevel].coins;
          i++
        ) {
          spawnCoin();
        }
        for (
          let i = 0;
          i < levelSettings[difficulty][currentLevel].enemies;
          i++
        ) {
          spawnEnemy();
        }
        const levelConfig = levelSettings[difficulty][currentLevel];
        if (levelConfig.bigEnemies && currentLevel >= 3) {
          for (let i = 0; i < levelConfig.bigEnemies; i++) {
            spawnBigEnemy();
          }
        }
        if (levelConfig.shooters && currentLevel >= 7) {
          for (let i = 0; i < levelConfig.shooters; i++) {
            spawnShooter();
          }
        }
        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);
        gameLoop = setInterval(update, 1000 / 60);
      }
      function onKeyDown(e) {
        keys[e.key.toLowerCase()] = true;
        if (e.key === " " || e.key === "Spacebar") {
          e.preventDefault();
          activateWave();
        }
        if (e.key === "Shift") {
          e.preventDefault();
          activateMagnet();
        }
        if (e.key === "Escape") {
          e.preventDefault();
          togglePause();
        }
      }
      function onKeyUp(e) {
        keys[e.key.toLowerCase()] = false;
      }
      function spawnCoin() {
        let x, y;
        do {
          x = Math.random() * (canvas.width - 20);
          y = Math.random() * (canvas.height - 200) + 20;
        } while (
          getDistance(x + 7.5, y + 7.5, player.x + 15, player.y + 15) <
          MIN_SPAWN_DISTANCE
        );
        coins.push({
          x: x,
          y: y,
          size: 15,
          color: "#d69e2e",
        });
      }
      function spawnEnemy() {
        let attempts = 0;
        let maxAttempts = 50;
        let x, y;
        do {
          let side = Math.floor(Math.random() * 4);
          switch (side) {
            case 0:
              x = Math.random() * canvas.width;
              y = -30;
              break;
            case 1:
              x = canvas.width + 30;
              y = Math.random() * canvas.height;
              break;
            case 2:
              x = Math.random() * canvas.width;
              y = canvas.height + 30;
              break;
            case 3:
              x = -30;
              y = Math.random() * canvas.height;
              break;
          }
          attempts++;
        } while (
          attempts < maxAttempts &&
          getDistance(x + 11, y + 11, player.x + 15, player.y + 15) <
            MIN_SPAWN_DISTANCE
        );
        if (attempts >= maxAttempts) {
          let corner = Math.floor(Math.random() * 4);
          switch (corner) {
            case 0:
              x = 0;
              y = 0;
              break;
            case 1:
              x = canvas.width;
              y = 0;
              break;
            case 2:
              x = 0;
              y = canvas.height;
              break;
            case 3:
              x = canvas.width;
              y = canvas.height;
              break;
          }
        }
        enemies.push({
          x: x,
          y: y,
          size: 22,
          speed:
            0.5 +
            Math.random() * levelSettings[difficulty][currentLevel].enemySpeed,
          color: "#e53e3e",
          type: "normal",
          trail: [],
        });
      }
      function spawnBigEnemy() {
        if (currentLevel < 3) return;
        let attempts = 0;
        let maxAttempts = 50;
        let x, y;
        do {
          let side = Math.floor(Math.random() * 4);
          switch (side) {
            case 0:
              x = Math.random() * canvas.width;
              y = -45;
              break;
            case 1:
              x = canvas.width + 45;
              y = Math.random() * canvas.height;
              break;
            case 2:
              x = Math.random() * canvas.width;
              y = canvas.height + 45;
              break;
            case 3:
              x = -45;
              y = Math.random() * canvas.height;
              break;
          }
          attempts++;
        } while (
          attempts < maxAttempts &&
          getDistance(x + 18.5, y + 18.5, player.x + 15, player.y + 15) <
            MIN_SPAWN_DISTANCE
        );
        if (attempts >= maxAttempts) {
          let corner = Math.floor(Math.random() * 4);
          switch (corner) {
            case 0:
              x = 0;
              y = 0;
              break;
            case 1:
              x = canvas.width;
              y = 0;
              break;
            case 2:
              x = 0;
              y = canvas.height;
              break;
            case 3:
              x = canvas.width;
              y = canvas.height;
              break;
          }
        }
        const levelConfig = levelSettings[difficulty][currentLevel];
        const speedMultiplier = 0.6 + currentLevel * 0.1;
        enemies.push({
          x: x,
          y: y,
          size: 37,
          speed:
            0.3 + Math.random() * (levelConfig.enemySpeed * speedMultiplier),
          color: "#9b2c2c",
          type: "big",
          trail: [],
        });
      }
      function spawnShooter() {
        let attempts = 0;
        let maxAttempts = 50;
        let x, y;
        do {
          let side = Math.floor(Math.random() * 4);
          switch (side) {
            case 0:
              x = Math.random() * canvas.width;
              y = -40;
              break;
            case 1:
              x = canvas.width + 40;
              y = Math.random() * canvas.height;
              break;
            case 2:
              x = Math.random() * canvas.width;
              y = canvas.height + 40;
              break;
            case 3:
              x = -40;
              y = Math.random() * canvas.height;
              break;
          }
          attempts++;
        } while (
          attempts < maxAttempts &&
          getDistance(x + 14, y + 14, player.x + 15, player.y + 15) <
            MIN_SPAWN_DISTANCE
        );
        if (attempts >= maxAttempts) {
          let corner = Math.floor(Math.random() * 4);
          switch (corner) {
            case 0:
              x = 0;
              y = 0;
              break;
            case 1:
              x = canvas.width;
              y = 0;
              break;
            case 2:
              x = 0;
              y = canvas.height;
              break;
            case 3:
              x = canvas.width;
              y = canvas.height;
              break;
          }
        }
        enemies.push({
          x: x,
          y: y,
          size: 28,
          speed: 0.4,
          color: "#3182ce",
          type: "shooter",
          lastShot: 0,
          shotCooldown: 2000,
          trail: [],
        });
      }
      function getDistance(x1, y1, x2, y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      }
      function activateWave() {
        const now = Date.now();
        if (now - lastWaveTime >= waveCooldown) {
          lastWaveTime = now;
          try {
            waveAudio.currentTime = 0;
            waveAudio
              .play()
              .catch((e) =>
                console.log("Ошибка воспроизведения звука волны:", e)
              );
          } catch (e) {
            console.log("Ошибка воспроизведения звука волны:", e);
          }
          createWaveEffect(
            player.x + player.size / 2,
            player.y + player.size / 2
          );
          for (let i = enemies.length - 1; i >= 0; i--) {
            let enemy = enemies[i];
            const enemyCenterX = enemy.x + enemy.size / 2;
            const enemyCenterY = enemy.y + enemy.size / 2;
            const playerCenterX = player.x + player.size / 2;
            const playerCenterY = player.y + player.size / 2;
            const distance = getDistance(
              playerCenterX,
              playerCenterY,
              enemyCenterX,
              enemyCenterY
            );
            if (distance <= waveRadius) {
              enemies.splice(i, 1);
              score += 2;
              document.getElementById("score").textContent = score;
              // Добавляем опыт за уничтожение врага
              addExp(5);
              const levelConfig = levelSettings[difficulty][currentLevel];
              if (score >= levelConfig.winScore) {
                if (currentLevel < 10) {
                  completeLevel();
                  return;
                } else {
                  winGame();
                  return;
                }
              }
              if (enemy.type === "big") {
                spawnBigEnemy();
              } else if (enemy.type === "shooter") {
                spawnShooter();
              } else {
                spawnEnemy();
              }
            }
          }
        }
      }
      function activateMagnet() {
        const now = Date.now();
        if (now - lastMagnetTime >= magnetCooldown) {
          lastMagnetTime = now;
          isMagnetActive = true;
          try {
            magnetAudio.currentTime = 0;
            magnetAudio
              .play()
              .catch((e) =>
                console.log("Ошибка воспроизведения звука магнита:", e)
              );
          } catch (e) {
            console.log("Ошибка воспроизведения звука магнита:", e);
          }
          createMagnetEffect(
            player.x + player.size / 2,
            player.y + player.size / 2
          );
          for (let i = coins.length - 1; i >= 0; i--) {
            let coin = coins[i];
            const coinCenterX = coin.x + coin.size / 2;
            const coinCenterY = coin.y + coin.size / 2;
            const playerCenterX = player.x + player.size / 2;
            const playerCenterY = player.y + player.size / 2;
            const distance = getDistance(
              playerCenterX,
              playerCenterY,
              coinCenterX,
              coinCenterY
            );
            if (distance <= magnetRadius) {
              createMagnetLine(
                coinCenterX,
                coinCenterY,
                playerCenterX,
                playerCenterY
              );
            }
          }
          setTimeout(() => {
            isMagnetActive = false;
          }, 300);
        }
      }
      function createWaveEffect(x, y) {
        const waveDiv = document.createElement("div");
        waveDiv.className = "wave-effect";
        const canvasRect = canvas.getBoundingClientRect();
        const centerX = x + canvasRect.left + window.scrollX;
        const centerY = y + canvasRect.top + window.scrollY;
        waveDiv.style.left = `${centerX}px`;
        waveDiv.style.top = `${centerY}px`;
        document.body.appendChild(waveDiv);
        setTimeout(() => {
          if (waveDiv.parentNode) waveDiv.parentNode.removeChild(waveDiv);
        }, 500);
      }
      function createMagnetEffect(x, y) {
        const magnetDiv = document.createElement("div");
        magnetDiv.className = "magnet-effect";
        const canvasRect = canvas.getBoundingClientRect();
        const centerX = x + canvasRect.left + window.scrollX;
        const centerY = y + canvasRect.top + window.scrollY;
        magnetDiv.style.left = `${centerX}px`;
        magnetDiv.style.top = `${centerY}px`;
        document.body.appendChild(magnetDiv);
        setTimeout(() => {
          if (magnetDiv.parentNode) magnetDiv.parentNode.removeChild(magnetDiv);
        }, 300);
      }
      function createMagnetLine(startX, startY, endX, endY) {
        const line = document.createElement("div");
        line.className = "magnet-line";
        const canvasRect = canvas.getBoundingClientRect();
        const absStartX = startX + canvasRect.left + window.scrollX;
        const absStartY = startY + canvasRect.top + window.scrollY;
        const absEndX = endX + canvasRect.left + window.scrollX;
        const absEndY = endY + canvasRect.top + window.scrollY;
        const length = Math.sqrt(
          Math.pow(absEndX - absStartX, 2) + Math.pow(absEndY - absStartY, 2)
        );
        const angle =
          (Math.atan2(absEndY - absStartY, absEndX - absStartX) * 180) /
          Math.PI;
        line.style.width = `${length}px`;
        line.style.left = `${absStartX}px`;
        line.style.top = `${absStartY}px`;
        line.style.transform = `rotate(${angle}deg)`;
        document.body.appendChild(line);
        setTimeout(() => {
          if (line.parentNode) line.parentNode.removeChild(line);
        }, 300);
      }
      function update() {
        if (gamePaused || !gameRunning) return;
        const oldX = player.x;
        const oldY = player.y;
        if (keys["a"] && player.x > 0) player.x -= player.speed;
        if (keys["d"] && player.x < canvas.width - player.size)
          player.x += player.speed;
        if (keys["w"] && player.y > 0) player.y -= player.speed;
        if (keys["s"] && player.y < canvas.height - player.size)
          player.y += player.speed;
        if (player.x !== oldX || player.y !== oldY) {
          trail.unshift({
            x: player.x + player.size / 2,
            y: player.y + player.size / 2,
          });
          if (trail.length > maxTrailLength) trail.pop();
        }
        enemies.forEach((enemy) => {
          const oldX = enemy.x;
          const oldY = enemy.y;
          if (enemy.type === "shooter") {
            let dx = player.x - enemy.x;
            let dy = player.y - enemy.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 0) {
              enemy.x += (dx / distance) * enemy.speed;
              enemy.y += (dy / distance) * enemy.speed;
            }
            const now = Date.now();
            if (now - enemy.lastShot >= enemy.shotCooldown) {
              enemy.lastShot = now;
              const angle = Math.atan2(dy, dx);
              bullets.push({
                x: enemy.x + enemy.size / 2,
                y: enemy.y + enemy.size / 2,
                vx: Math.cos(angle) * 5,
                vy: Math.sin(angle) * 5,
                size: 8,
                color: "#e53e3e",
              });
              try {
                waveAudio.currentTime = 0;
                waveAudio
                  .play()
                  .catch((e) =>
                    console.log("Ошибка воспроизведения звука выстрела:", e)
                  );
              } catch (e) {
                console.log("Ошибка воспроизведения звука выстрела:", e);
              }
            }
          } else {
            let dx = player.x - enemy.x;
            let dy = player.y - enemy.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 0) {
              enemy.x += (dx / distance) * enemy.speed;
              enemy.y += (dy / distance) * enemy.speed;
            }
          }
          if (enemy.x !== oldX || enemy.y !== oldY) {
            enemy.trail.unshift({
              x: enemy.x + enemy.size / 2,
              y: enemy.y + enemy.size / 2,
            });
            if (enemy.trail.length > maxTrailLength) {
              enemy.trail.pop();
            }
          }
        });
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.x += bullet.vx;
          bullet.y += bullet.vy;
          if (
            bullet.x < -10 ||
            bullet.x > canvas.width + 10 ||
            bullet.y < -10 ||
            bullet.y > canvas.height + 10
          ) {
            bullets.splice(i, 1);
            continue;
          }
          if (checkCollision(bullet, player)) {
            bullets.splice(i, 1);
            lives--;
            document.getElementById("lives").textContent = lives;
            try {
              hitAudio.currentTime = 0;
              hitAudio
                .play()
                .catch((e) =>
                  console.log("Ошибка воспроизведения звука попадания:", e)
                );
            } catch (e) {
              console.log("Ошибка воспроизведения звука попадания:", e);
            }
            if (lives <= 0) {
              endGame(false);
            }
          }
        }
        if (isMagnetActive) {
          for (let i = coins.length - 1; i >= 0; i--) {
            let coin = coins[i];
            const coinCenterX = coin.x + coin.size / 2;
            const coinCenterY = coin.y + coin.size / 2;
            const playerCenterX = player.x + player.size / 2;
            const playerCenterY = player.y + player.size / 2;
            const distance = getDistance(
              playerCenterX,
              playerCenterY,
              coinCenterX,
              coinCenterY
            );
            if (distance <= magnetRadius) {
              let dx = playerCenterX - coinCenterX;
              let dy = playerCenterY - coinCenterY;
              let length = Math.sqrt(dx * dx + dy * dy);
              if (length > 0) {
                dx /= length;
                dy /= length;
              }
              coin.x += dx * magnetStrength * 10;
              coin.y += dy * magnetStrength * 10;
            }
          }
        }
        for (let i = coins.length - 1; i >= 0; i--) {
          let coin = coins[i];
          if (checkCollision(player, coin)) {
            coins.splice(i, 1);
            score++;
            document.getElementById("score").textContent = score;
            // Добавляем опыт за сбор монетки (1 EXP за монетку)
            addExp(1);
            try {
              coinAudio.currentTime = 0;
              coinAudio
                .play()
                .catch((e) =>
                  console.log("Ошибка воспроизведения звука монеты:", e)
                );
            } catch (e) {
              console.log("Ошибка воспроизведения звука монеты:", e);
            }
            const levelConfig = levelSettings[difficulty][currentLevel];
            if (score >= levelConfig.winScore) {
              if (currentLevel < 10) {
                completeLevel();
              } else {
                winGame();
              }
            } else {
              spawnCoin();
            }
          }
        }
        for (let i = enemies.length - 1; i >= 0; i--) {
          let enemy = enemies[i];
          if (enemy.type !== "shooter" && checkCollision(player, enemy)) {
            enemies.splice(i, 1);
            lives--;
            document.getElementById("lives").textContent = lives;
            try {
              hitAudio.currentTime = 0;
              hitAudio
                .play()
                .catch((e) =>
                  console.log("Ошибка воспроизведения звука удара:", e)
                );
            } catch (e) {
              console.log("Ошибка воспроизведения звука удара:", e);
            }
            // Добавляем опыт за столкновение с врагом
            addExp(3);
            if (enemy.type === "big") {
              spawnBigEnemy();
            } else if (enemy.type === "shooter") {
              spawnShooter();
            } else {
              spawnEnemy();
            }
            if (lives <= 0) {
              endGame(false);
            }
          }
        }
        if (Math.random() < 0.015) {
          const levelConfig = levelSettings[difficulty][currentLevel];
          if (
            enemies.length <
            levelConfig.enemies +
              (levelConfig.bigEnemies || 0) +
              (levelConfig.shooters || 0) +
              5
          ) {
            if (
              currentLevel >= 3 &&
              Math.random() < (levelConfig.bigEnemyChance || 0)
            ) {
              spawnBigEnemy();
            } else {
              spawnEnemy();
            }
          }
        }
        updateWaveCooldown();
        updateMagnetCooldown();
        render();
      }
      function updateWaveCooldown() {
        const now = Date.now();
        const timeLeft = waveCooldown - (now - lastWaveTime);
        const cooldownElement = document.getElementById("waveCooldown");
        if (timeLeft > 0) {
          const secondsLeft = Math.ceil(timeLeft / 1000);
          cooldownElement.textContent = secondsLeft + "с";
          cooldownElement.style.color = "#e53e3e";
        } else {
          cooldownElement.textContent = "Готова";
          cooldownElement.style.color = "#48bb78";
        }
      }
      function updateMagnetCooldown() {
        const now = Date.now();
        const timeLeft = magnetCooldown - (now - lastMagnetTime);
        const cooldownElement = document.getElementById("magnetCooldown");
        if (timeLeft > 0) {
          const secondsLeft = Math.ceil(timeLeft / 1000);
          cooldownElement.textContent = secondsLeft + "с";
          cooldownElement.style.color = "#e53e3e";
        } else {
          cooldownElement.textContent = "Готов";
          cooldownElement.style.color = "#48bb78";
        }
      }
      function checkCollision(obj1, obj2) {
        return (
          obj1.x < obj2.x + obj2.size &&
          obj1.x + obj1.size > obj2.x &&
          obj1.y < obj2.y + obj2.size &&
          obj1.y + obj1.size > obj2.y
        );
      }
      function render() {
        ctx.fillStyle = "#1a202c";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < trail.length; i++) {
          const point = trail[i];
          const alpha = 1 - i / trail.length;
          const size = 6 * (1 - i / trail.length);
          ctx.fillStyle = `rgba(72, 187, 120, ${alpha * 0.7})`;
          ctx.fillRect(point.x - size / 2, point.y - size / 2, size, size);
        }
        enemies.forEach((enemy) => {
          for (let i = 0; i < enemy.trail.length; i++) {
            const point = enemy.trail[i];
            const alpha = 1 - i / enemy.trail.length;
            const size = 5 * (1 - i / enemy.trail.length);
            let color;
            if (enemy.type === "big") {
              color = "#9b2c2c";
            } else if (enemy.type === "shooter") {
              color = "#3182ce";
            } else {
              color = "#e53e3e";
            }
            ctx.fillStyle = `rgba(${hexToRgb(color)}, ${alpha * 0.6})`;
            ctx.fillRect(point.x - size / 2, point.y - size / 2, size, size);
          }
        });
        ctx.fillStyle = "#48bb78";
        ctx.fillRect(player.x, player.y, player.size, player.size);
        coins.forEach((coin) => {
          ctx.fillStyle = "#d69e2e";
          ctx.fillRect(coin.x, coin.y, coin.size, coin.size);
        });
        enemies.forEach((enemy) => {
          ctx.fillStyle = enemy.color;
          ctx.fillRect(enemy.x, enemy.y, enemy.size, enemy.size);
          if (enemy.type === "big") {
            ctx.fillStyle = "#fed7d7";
            ctx.fillRect(
              enemy.x + 7,
              enemy.y + 7,
              enemy.size - 14,
              enemy.size - 14
            );
          }
        });
        bullets.forEach((bullet) => {
          ctx.fillStyle = bullet.color;
          ctx.fillRect(
            bullet.x - bullet.size / 2,
            bullet.y - bullet.size / 2,
            bullet.size,
            bullet.size
          );
        });
      }
      function endGame(win) {
        gameRunning = false;
        gamePaused = false;
        clearInterval(gameLoop);
        document.removeEventListener("keydown", onKeyDown);
        document.removeEventListener("keyup", onKeyUp);
        totalCoins += score;
        document.getElementById("totalCoins").textContent = totalCoins;
        localStorage.setItem("totalCoins", totalCoins);
        if (win || score >= levelSettings[difficulty][currentLevel].winScore) {
          if (!completedLevels.includes(currentLevel)) {
            completedLevels.push(currentLevel);
            if (unlockedLevels < 10) {
              unlockedLevels++;
            }
            if (currentLevel === 5) {
              showNotification("🔓 Открыт Эпизод 2: Тёмные глубины!");
            }
            lastAttemptedLevel = currentLevel + 1;
          }
        } else {
          lastAttemptedLevel = currentLevel;
        }
        saveProgress();
        document.getElementById(
          "finalScore"
        ).textContent = `Сыграно: Уровень ${currentLevel}. Собрано: ${score} монет. Всего: ${totalCoins}`;
        document.getElementById("gameOver").style.display = "block";
      }
      function completeLevel() {
        gameRunning = false;
        gamePaused = false;
        clearInterval(gameLoop);
        document.removeEventListener("keydown", onKeyDown);
        document.removeEventListener("keyup", onKeyUp);
        totalCoins += score;
        document.getElementById("totalCoins").textContent = totalCoins;
        localStorage.setItem("totalCoins", totalCoins);
        if (!completedLevels.includes(currentLevel)) {
          completedLevels.push(currentLevel);
          if (unlockedLevels < 10) {
            unlockedLevels++;
          }
          if (currentLevel === 5) {
            showNotification("🔓 Открыт Эпизод 2: Тёмные глубины!");
          }
          lastAttemptedLevel = currentLevel + 1;
        }
        saveProgress();
        document.getElementById(
          "levelCompleteText"
        ).textContent = `Уровень ${currentLevel} пройден! Собрано: ${score} монет. Всего: ${totalCoins}`;
        document.getElementById("levelComplete").style.display = "block";
      }
      function nextLevel() {
        currentLevel = Math.min(currentLevel + 1, 10);
        document.getElementById("level").textContent = currentLevel;
        document.getElementById("levelComplete").style.display = "none";
        coins = [];
        enemies = [];
        bullets = [];
        keys = {};
        gameRunning = true;
        gamePaused = false;
        initGame();
      }
      function winGame() {
        endGame(true);
      }
      function startGame() {
        if (lastAttemptedLevel >= 1 && lastAttemptedLevel <= 10) {
          currentLevel = lastAttemptedLevel;
        } else {
          currentLevel = 1;
        }
        document.getElementById("startScreen").style.display = "none";
        document.getElementById("gameContainer").style.display = "block";
        document.getElementById("gloryRoad").style.display = "none";
        document.getElementById("shopScreen").style.display = "none";
        document.getElementById("resetScreen").style.display = "none";
        player = { x: 400, y: 500, size: 30, speed: 3, color: "#48bb78" };
        // Применяем все улучшения
        Object.keys(upgradeConfig).forEach((type) => {
          if (upgrades[type] > 0) {
            applyUpgradeEffect(type);
          }
        });
        coins = [];
        enemies = [];
        bullets = [];
        score = 0;
        lives = maxLives;
        gamePaused = false;
        lastWaveTime = 0;
        lastMagnetTime = 0;
        isMagnetActive = false;
        keys = {};
        document.getElementById("score").textContent = score;
        document.getElementById("lives").textContent = lives;
        document.getElementById("level").textContent = currentLevel;
        document.getElementById("waveCooldown").textContent = "Готова";
        document.getElementById("waveCooldown").style.color = "#48bb78";
        document.getElementById("magnetCooldown").textContent = "Готов";
        document.getElementById("magnetCooldown").style.color = "#48bb78";
        gameRunning = true;
        initGame();
      }
      function restartGame() {
        document.getElementById("gameOver").style.display = "none";
        document.getElementById("winScreen").style.display = "none";
        startGame();
      }
      window.addEventListener("load", function () {
        loadProgress();
        updateDailyBonusButton();
        updateResetButton();
      });
      // Добавляем обработку изменения размера окна
      window.addEventListener("resize", function () {
        if (gameRunning && canvas) {
          const gameBoard = document.querySelector(".game-board");
          canvas.width = gameBoard.clientWidth;
          canvas.height = gameBoard.clientHeight;
          // Центрируем игрока при изменении размера
          player.x = canvas.width / 2 - player.size / 2;
          player.y = canvas.height / 2 - player.size / 2;
        }
      });
    </script>
  </body>
</html>